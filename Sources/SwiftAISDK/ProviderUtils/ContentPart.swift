import Foundation

/**
 Content part types for prompts and messages.

 Port of `@ai-sdk/provider-utils/types/content-part.ts`.

 Content parts represent different types of content that can appear in messages:
 - Text content (TextPart)
 - Image content (ImagePart)
 - File content (FilePart)
 - Reasoning content (ReasoningPart)
 - Tool calls and results (ToolCallPart, ToolResultPart)
 - Tool approval requests and responses (ToolApprovalRequest, ToolApprovalResponse)
 */

// MARK: - ProviderOptions

/**
 Additional provider-specific options.

 They are passed through to the provider from the AI SDK and enable
 provider-specific functionality that can be fully encapsulated in the provider.

 Port of `@ai-sdk/provider-utils/types/provider-options.ts`.
 */
public typealias ProviderOptions = SharedV3ProviderOptions

// MARK: - Text Content

/**
 Text content part of a prompt. It contains a string of text.
 */
public struct TextPart: Sendable, Equatable {
    public let type: String = "text"

    /// The text content.
    public let text: String

    /// Additional provider-specific metadata. They are passed through
    /// to the provider from the AI SDK and enable provider-specific
    /// functionality that can be fully encapsulated in the provider.
    public let providerOptions: ProviderOptions?

    public init(text: String, providerOptions: ProviderOptions? = nil) {
        self.text = text
        self.providerOptions = providerOptions
    }
}

// MARK: - Image Content

/**
 Image content part of a prompt. It contains an image.
 */
public struct ImagePart: Sendable, Equatable {
    public let type: String = "image"

    /// Image data. Can either be:
    /// - data: a base64-encoded string or raw Data
    /// - URL: a URL that points to the image
    public let image: DataContentOrURL

    /// Optional IANA media type of the image.
    ///
    /// See: https://www.iana.org/assignments/media-types/media-types.xhtml
    public let mediaType: String?

    /// Additional provider-specific metadata. They are passed through
    /// to the provider from the AI SDK and enable provider-specific
    /// functionality that can be fully encapsulated in the provider.
    public let providerOptions: ProviderOptions?

    public init(
        image: DataContentOrURL,
        mediaType: String? = nil,
        providerOptions: ProviderOptions? = nil
    ) {
        self.image = image
        self.mediaType = mediaType
        self.providerOptions = providerOptions
    }
}

// MARK: - File Content

/**
 File content part of a prompt. It contains a file.
 */
public struct FilePart: Sendable, Equatable {
    public let type: String = "file"

    /// File data. Can either be:
    /// - data: a base64-encoded string or raw Data
    /// - URL: a URL that points to the file
    public let data: DataContentOrURL

    /// Optional filename of the file.
    public let filename: String?

    /// IANA media type of the file.
    ///
    /// See: https://www.iana.org/assignments/media-types/media-types.xhtml
    public let mediaType: String

    /// Additional provider-specific metadata. They are passed through
    /// to the provider from the AI SDK and enable provider-specific
    /// functionality that can be fully encapsulated in the provider.
    public let providerOptions: ProviderOptions?

    public init(
        data: DataContentOrURL,
        mediaType: String,
        filename: String? = nil,
        providerOptions: ProviderOptions? = nil
    ) {
        self.data = data
        self.mediaType = mediaType
        self.filename = filename
        self.providerOptions = providerOptions
    }
}

// MARK: - Reasoning Content

/**
 Reasoning content part of a prompt. It contains reasoning text.
 */
public struct ReasoningPart: Sendable, Equatable {
    public let type: String = "reasoning"

    /// The reasoning text.
    public let text: String

    /// Additional provider-specific metadata. They are passed through
    /// to the provider from the AI SDK and enable provider-specific
    /// functionality that can be fully encapsulated in the provider.
    public let providerOptions: ProviderOptions?

    public init(text: String, providerOptions: ProviderOptions? = nil) {
        self.text = text
        self.providerOptions = providerOptions
    }
}

// MARK: - Tool Call

/**
 Tool call content part of a prompt. It contains a tool call (usually generated by the AI model).
 */
public struct ToolCallPart: Sendable, Equatable {
    public let type: String = "tool-call"

    /// ID of the tool call. This ID is used to match the tool call with the tool result.
    public let toolCallId: String

    /// Name of the tool that is being called.
    public let toolName: String

    /// Arguments of the tool call. This is a JSON-serializable object that matches the tool's input schema.
    public let input: JSONValue

    /// Additional provider-specific metadata. They are passed through
    /// to the provider from the AI SDK and enable provider-specific
    /// functionality that can be fully encapsulated in the provider.
    public let providerOptions: ProviderOptions?

    /// Whether the tool call was executed by the provider.
    public let providerExecuted: Bool?

    public init(
        toolCallId: String,
        toolName: String,
        input: JSONValue,
        providerOptions: ProviderOptions? = nil,
        providerExecuted: Bool? = nil
    ) {
        self.toolCallId = toolCallId
        self.toolName = toolName
        self.input = input
        self.providerOptions = providerOptions
        self.providerExecuted = providerExecuted
    }
}

// MARK: - Tool Result

/**
 Tool result content part of a prompt. It contains the result of the tool call with the matching ID.
 */
public struct ToolResultPart: Sendable, Equatable {
    public let type: String = "tool-result"

    /// ID of the tool call that this result is associated with.
    public let toolCallId: String

    /// Name of the tool that generated this result.
    public let toolName: String

    /// Result of the tool call. This is a JSON-serializable object.
    public let output: LanguageModelV3ToolResultOutput

    /// Additional provider-specific metadata. They are passed through
    /// to the provider from the AI SDK and enable provider-specific
    /// functionality that can be fully encapsulated in the provider.
    public let providerOptions: ProviderOptions?

    public init(
        toolCallId: String,
        toolName: String,
        output: LanguageModelV3ToolResultOutput,
        providerOptions: ProviderOptions? = nil
    ) {
        self.toolCallId = toolCallId
        self.toolName = toolName
        self.output = output
        self.providerOptions = providerOptions
    }
}

// MARK: - Tool Approval

/**
 Tool approval request prompt part.

 Port of `@ai-sdk/provider-utils/types/tool-approval-request.ts`.
 */
public struct ToolApprovalRequest: Sendable, Equatable {
    public let type: String = "tool-approval-request"

    /// ID of the tool approval.
    public let approvalId: String

    /// ID of the tool call that the approval request is for.
    public let toolCallId: String

    public init(approvalId: String, toolCallId: String) {
        self.approvalId = approvalId
        self.toolCallId = toolCallId
    }
}

/**
 Tool approval response prompt part.

 Port of `@ai-sdk/provider-utils/types/tool-approval-response.ts`.
 */
public struct ToolApprovalResponse: Sendable, Equatable {
    public let type: String = "tool-approval-response"

    /// ID of the tool approval.
    public let approvalId: String

    /// Flag indicating whether the approval was granted or denied.
    public let approved: Bool

    /// Optional reason for the approval or denial.
    public let reason: String?

    public init(approvalId: String, approved: Bool, reason: String? = nil) {
        self.approvalId = approvalId
        self.approved = approved
        self.reason = reason
    }
}
