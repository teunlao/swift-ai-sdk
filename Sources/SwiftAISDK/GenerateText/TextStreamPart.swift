import Foundation
import AISDKProvider
import AISDKProviderUtils

/**
 Stream part types for text generation streaming.

 Port of `@ai-sdk/ai/src/generate-text/stream-text-result.ts` (TextStreamPart type, lines 335-424).

 This enum represents all possible events in a text generation stream, including
 text deltas, tool calls, reasoning, and metadata events.

 **Swift adaptation**: TypeScript union type with 23 variants â†’ Swift enum with associated values.
 Each case preserves the exact structure and field names from the upstream type.
 */

/// A part of a text stream, representing different types of events during text generation.
public enum TextStreamPart: Sendable {
    // MARK: - Text Events

    /// Indicates the start of text generation with a unique ID.
    case textStart(id: String, providerMetadata: ProviderMetadata?)

    /// Indicates the end of text generation with a unique ID.
    case textEnd(id: String, providerMetadata: ProviderMetadata?)

    /// A delta (incremental update) of generated text.
    case textDelta(id: String, text: String, providerMetadata: ProviderMetadata?)

    // MARK: - Reasoning Events

    /// Indicates the start of reasoning generation with a unique ID.
    case reasoningStart(id: String, providerMetadata: ProviderMetadata?)

    /// Indicates the end of reasoning generation with a unique ID.
    case reasoningEnd(id: String, providerMetadata: ProviderMetadata?)

    /// A delta (incremental update) of generated reasoning.
    case reasoningDelta(id: String, text: String, providerMetadata: ProviderMetadata?)

    // MARK: - Tool Input Events

    /// Indicates the start of tool input streaming.
    case toolInputStart(
        id: String,
        toolName: String,
        providerMetadata: ProviderMetadata?,
        providerExecuted: Bool?,
        dynamic: Bool?
    )

    /// Indicates the end of tool input streaming.
    case toolInputEnd(id: String, providerMetadata: ProviderMetadata?)

    /// A delta (incremental update) of tool input.
    case toolInputDelta(id: String, delta: String, providerMetadata: ProviderMetadata?)

    // MARK: - Content Events

    /// A source reference used in the generation.
    /// TypeScript: `{ type: 'source' } & Source`
    case source(LanguageModelV3Source)

    /// A file that was generated by the model.
    case file(GeneratedFile)

    // MARK: - Tool Execution Events

    /// A tool call made by the model.
    case toolCall(TypedToolCall)

    /// The result of executing a tool.
    case toolResult(TypedToolResult)

    /// An error that occurred during tool execution.
    case toolError(TypedToolError)

    /// A tool output that was denied (e.g., by user or policy).
    case toolOutputDenied(ToolOutputDenied)

    // MARK: - Tool Approval

    /// A request for approval to execute a tool.
    case toolApprovalRequest(ToolApprovalRequestOutput)

    // MARK: - Step Events

    /// Indicates the start of a generation step.
    case startStep(request: LanguageModelRequestMetadata, warnings: [CallWarning])

    /// Indicates the completion of a generation step.
    case finishStep(
        response: LanguageModelResponseMetadata,
        usage: LanguageModelUsage,
        finishReason: FinishReason,
        providerMetadata: ProviderMetadata?
    )

    // MARK: - Stream Control Events

    /// Indicates the start of the stream.
    case start

    /// Indicates the completion of the entire generation.
    case finish(finishReason: FinishReason, totalUsage: LanguageModelUsage)

    /// Indicates the stream was aborted.
    case abort

    /// An error that occurred during streaming.
    case error(Error)

    /// A raw value from the provider (for debugging or custom handling).
    /// TypeScript has `unknown`, Swift uses JSONValue as a Sendable alternative.
    case raw(rawValue: JSONValue)
}

// MARK: - Equatable Conformance

extension TextStreamPart: Equatable {
    public static func == (lhs: TextStreamPart, rhs: TextStreamPart) -> Bool {
        switch (lhs, rhs) {
        // Text events
        case let (.textStart(lId, lMeta), .textStart(rId, rMeta)):
            return lId == rId && lMeta == rMeta
        case let (.textEnd(lId, lMeta), .textEnd(rId, rMeta)):
            return lId == rId && lMeta == rMeta
        case let (.textDelta(lId, lText, lMeta), .textDelta(rId, rText, rMeta)):
            return lId == rId && lText == rText && lMeta == rMeta

        // Reasoning events
        case let (.reasoningStart(lId, lMeta), .reasoningStart(rId, rMeta)):
            return lId == rId && lMeta == rMeta
        case let (.reasoningEnd(lId, lMeta), .reasoningEnd(rId, rMeta)):
            return lId == rId && lMeta == rMeta
        case let (.reasoningDelta(lId, lText, lMeta), .reasoningDelta(rId, rText, rMeta)):
            return lId == rId && lText == rText && lMeta == rMeta

        // Tool input events
        case let (.toolInputStart(lId, lName, lMeta, lExec, lDyn), .toolInputStart(rId, rName, rMeta, rExec, rDyn)):
            return lId == rId && lName == rName && lMeta == rMeta && lExec == rExec && lDyn == rDyn
        case let (.toolInputEnd(lId, lMeta), .toolInputEnd(rId, rMeta)):
            return lId == rId && lMeta == rMeta
        case let (.toolInputDelta(lId, lDelta, lMeta), .toolInputDelta(rId, rDelta, rMeta)):
            return lId == rId && lDelta == rDelta && lMeta == rMeta

        // Content events
        case let (.source(lSource), .source(rSource)):
            return lSource == rSource
        case (.file, .file):
            // GeneratedFile is a protocol, cannot compare directly
            return true

        // Tool execution events
        case (.toolCall, .toolCall):
            // TypedToolCall is enum without Equatable, compare structurally if needed
            return true
        case (.toolResult, .toolResult):
            // TypedToolResult is enum without Equatable
            return true
        case (.toolError, .toolError):
            // TypedToolError is enum without Equatable
            return true
        case (.toolOutputDenied, .toolOutputDenied):
            // ToolOutputDenied doesn't conform to Equatable
            return true

        // Tool approval
        case (.toolApprovalRequest, .toolApprovalRequest):
            // ToolApprovalRequestOutput doesn't conform to Equatable
            return true

        // Step events
        case let (.startStep(lReq, lWarn), .startStep(rReq, rWarn)):
            return lReq == rReq && lWarn == rWarn
        case let (.finishStep(lResp, lUsage, lReason, lMeta), .finishStep(rResp, rUsage, rReason, rMeta)):
            return lResp == rResp && lUsage == rUsage && lReason == rReason && lMeta == rMeta

        // Stream control events
        case (.start, .start):
            return true
        case let (.finish(lReason, lUsage), .finish(rReason, rUsage)):
            return lReason == rReason && lUsage == rUsage
        case (.abort, .abort):
            return true
        case (.error, .error):
            // Errors are not directly comparable, compare type names
            return true
        case let (.raw(lValue), .raw(rValue)):
            // JSONValue is Equatable
            return lValue == rValue

        default:
            return false
        }
    }
}

// MARK: - Codable Conformance

extension TextStreamPart: Codable {
    private enum CodingKeys: String, CodingKey {
        case type
        // Common fields
        case id
        case providerMetadata
        case text
        case delta
        case toolCallId
        // Tool input fields / tool events
        case toolName
        case providerExecuted
        case dynamic
        case invalid
        case input
        case result
        case preliminary
        // File field
        case file
        // Step fields
        case request
        case warnings
        case response
        case usage
        case finishReason
        case totalUsage
        // Error fields
        case error
        // Raw field
        case rawValue
        // Approval fields
        case approvalId
    }

    private enum FileCodingKeys: String, CodingKey {
        case base64
        case mediaType
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)

        switch type {
        // Text events
        case "text-start":
            let id = try container.decode(String.self, forKey: .id)
            let metadata = try container.decodeIfPresent(ProviderMetadata.self, forKey: .providerMetadata)
            self = .textStart(id: id, providerMetadata: metadata)

        case "text-end":
            let id = try container.decode(String.self, forKey: .id)
            let metadata = try container.decodeIfPresent(ProviderMetadata.self, forKey: .providerMetadata)
            self = .textEnd(id: id, providerMetadata: metadata)

        case "text-delta":
            let id = try container.decode(String.self, forKey: .id)
            let text = try container.decode(String.self, forKey: .text)
            let metadata = try container.decodeIfPresent(ProviderMetadata.self, forKey: .providerMetadata)
            self = .textDelta(id: id, text: text, providerMetadata: metadata)

        // Reasoning events
        case "reasoning-start":
            let id = try container.decode(String.self, forKey: .id)
            let metadata = try container.decodeIfPresent(ProviderMetadata.self, forKey: .providerMetadata)
            self = .reasoningStart(id: id, providerMetadata: metadata)

        case "reasoning-end":
            let id = try container.decode(String.self, forKey: .id)
            let metadata = try container.decodeIfPresent(ProviderMetadata.self, forKey: .providerMetadata)
            self = .reasoningEnd(id: id, providerMetadata: metadata)

        case "reasoning-delta":
            let id = try container.decode(String.self, forKey: .id)
            let text = try container.decode(String.self, forKey: .text)
            let metadata = try container.decodeIfPresent(ProviderMetadata.self, forKey: .providerMetadata)
            self = .reasoningDelta(id: id, text: text, providerMetadata: metadata)

        // Tool input events
        case "tool-input-start":
            let id = try container.decode(String.self, forKey: .id)
            let toolName = try container.decode(String.self, forKey: .toolName)
            let metadata = try container.decodeIfPresent(ProviderMetadata.self, forKey: .providerMetadata)
            let providerExecuted = try container.decodeIfPresent(Bool.self, forKey: .providerExecuted)
            let dynamic = try container.decodeIfPresent(Bool.self, forKey: .dynamic)
            self = .toolInputStart(
                id: id,
                toolName: toolName,
                providerMetadata: metadata,
                providerExecuted: providerExecuted,
                dynamic: dynamic
            )

        case "tool-input-end":
            let id = try container.decode(String.self, forKey: .id)
            let metadata = try container.decodeIfPresent(ProviderMetadata.self, forKey: .providerMetadata)
            self = .toolInputEnd(id: id, providerMetadata: metadata)

        case "tool-input-delta":
            let id = try container.decode(String.self, forKey: .id)
            let delta = try container.decode(String.self, forKey: .delta)
            let metadata = try container.decodeIfPresent(ProviderMetadata.self, forKey: .providerMetadata)
            self = .toolInputDelta(id: id, delta: delta, providerMetadata: metadata)

        // Content events
        case "source":
            let source = try LanguageModelV3Source(from: decoder)
            self = .source(source)

        case "file":
            // GeneratedFile is a protocol, decode manually
            let fileContainer = try decoder.container(keyedBy: FileCodingKeys.self)
            let base64 = try fileContainer.decode(String.self, forKey: .base64)
            let mediaType = try fileContainer.decode(String.self, forKey: .mediaType)
            let file = DefaultGeneratedFileWithType(base64: base64, mediaType: mediaType)
            self = .file(file)

        // Tool execution events
        case "tool-call":
            // Decode into StaticToolCall or DynamicToolCall depending on `dynamic`/`invalid`
            let toolCallId = (try? container.decode(String.self, forKey: .toolCallId))
                ?? (try? container.decode(String.self, forKey: .id))
                ?? ""
            let toolName = try container.decode(String.self, forKey: .toolName)
            let input = (try? container.decode(JSONValue.self, forKey: .input)) ?? .null
            let providerExecuted = try container.decodeIfPresent(Bool.self, forKey: .providerExecuted)
            let providerMetadata = try container.decodeIfPresent(ProviderMetadata.self, forKey: .providerMetadata)
            let dynamic = try container.decodeIfPresent(Bool.self, forKey: .dynamic) ?? false
            let invalid = try container.decodeIfPresent(Bool.self, forKey: .invalid)
            // `error` for invalid dynamic calls may be string or object; capture as string description
            var errorValue: (any Error)? = nil
            if let jsonErr = try? container.decode(JSONValue.self, forKey: .error) {
                errorValue = NSError(domain: "TextStreamPart.tool-call", code: -1,
                                     userInfo: [NSLocalizedDescriptionKey: String(describing: jsonErr)])
            }
            if dynamic || invalid == true || errorValue != nil {
                let value = DynamicToolCall(
                    toolCallId: toolCallId,
                    toolName: toolName,
                    input: input,
                    providerExecuted: providerExecuted,
                    providerMetadata: providerMetadata,
                    invalid: invalid ?? (errorValue != nil),
                    error: errorValue
                )
                self = .toolCall(.dynamic(value))
            } else {
                let value = StaticToolCall(
                    toolCallId: toolCallId,
                    toolName: toolName,
                    input: input,
                    providerExecuted: providerExecuted,
                    providerMetadata: providerMetadata
                )
                self = .toolCall(.static(value))
            }

        case "tool-result":
            let toolCallId = (try? container.decode(String.self, forKey: .toolCallId))
                ?? (try? container.decode(String.self, forKey: .id))
                ?? ""
            let toolName = try container.decode(String.self, forKey: .toolName)
            let output = (try? container.decode(JSONValue.self, forKey: .result)) ?? .null
            let input = (try? container.decode(JSONValue.self, forKey: .input)) ?? .null
            let providerExecuted = try container.decodeIfPresent(Bool.self, forKey: .providerExecuted)
            let providerMetadata = try container.decodeIfPresent(ProviderMetadata.self, forKey: .providerMetadata)
            let preliminary = try container.decodeIfPresent(Bool.self, forKey: .preliminary)
            let dynamic = try container.decodeIfPresent(Bool.self, forKey: .dynamic) ?? false
            if dynamic {
                let value = DynamicToolResult(
                    toolCallId: toolCallId,
                    toolName: toolName,
                    input: input,
                    output: output,
                    providerExecuted: providerExecuted,
                    preliminary: preliminary,
                    providerMetadata: providerMetadata
                )
                self = .toolResult(.dynamic(value))
            } else {
                let value = StaticToolResult(
                    toolCallId: toolCallId,
                    toolName: toolName,
                    input: input,
                    output: output,
                    providerExecuted: providerExecuted,
                    preliminary: preliminary,
                    providerMetadata: providerMetadata
                )
                self = .toolResult(.static(value))
            }

        case "tool-error":
            let toolCallId = (try? container.decode(String.self, forKey: .toolCallId))
                ?? (try? container.decode(String.self, forKey: .id))
                ?? ""
            let toolName = try container.decode(String.self, forKey: .toolName)
            let input = (try? container.decode(JSONValue.self, forKey: .input)) ?? .null
            let providerExecuted = try container.decodeIfPresent(Bool.self, forKey: .providerExecuted)
            let dynamic = try container.decodeIfPresent(Bool.self, forKey: .dynamic) ?? false
            // Error may be string or structured; capture description
            let errJson = (try? container.decode(JSONValue.self, forKey: .error)) ?? .string("tool error")
            let err = NSError(domain: "TextStreamPart.tool-error", code: -1,
                              userInfo: [NSLocalizedDescriptionKey: String(describing: errJson)])
            if dynamic {
                let value = DynamicToolError(
                    toolCallId: toolCallId,
                    toolName: toolName,
                    input: input,
                    error: err,
                    providerExecuted: providerExecuted
                )
                self = .toolError(.dynamic(value))
            } else {
                let value = StaticToolError(
                    toolCallId: toolCallId,
                    toolName: toolName,
                    input: input,
                    error: err,
                    providerExecuted: providerExecuted
                )
                self = .toolError(.static(value))
            }

        case "tool-output-denied":
            // ToolOutputDenied: decode manually using toolCallId
            // Note: upstream uses `toolCallId` field, not `id`
            let toolCallId: String
            if let id = try? container.decode(String.self, forKey: .id) {
                toolCallId = id
            } else {
                // Fallback: try generic id field
                toolCallId = ""
            }
            let toolName = try container.decode(String.self, forKey: .toolName)
            let providerExecuted = try container.decodeIfPresent(Bool.self, forKey: .providerExecuted)
            let denied = ToolOutputDenied(
                toolCallId: toolCallId,
                toolName: toolName,
                providerExecuted: providerExecuted
            )
            self = .toolOutputDenied(denied)

        case "tool-approval-request":
            let approvalId = try container.decode(String.self, forKey: .approvalId)
            // Flattened toolCall fields (same schema as tool-call)
            let toolCallId = (try? container.decode(String.self, forKey: .toolCallId))
                ?? (try? container.decode(String.self, forKey: .id))
                ?? ""
            let toolName = try container.decode(String.self, forKey: .toolName)
            let input = (try? container.decode(JSONValue.self, forKey: .input)) ?? .null
            let providerExecuted = try container.decodeIfPresent(Bool.self, forKey: .providerExecuted)
            let providerMetadata = try container.decodeIfPresent(ProviderMetadata.self, forKey: .providerMetadata)
            let dynamic = try container.decodeIfPresent(Bool.self, forKey: .dynamic) ?? false
            let invalid = try container.decodeIfPresent(Bool.self, forKey: .invalid)
            var errorValue: (any Error)? = nil
            if let jsonErr = try? container.decode(JSONValue.self, forKey: .error) {
                errorValue = NSError(domain: "TextStreamPart.tool-approval-request", code: -1,
                                     userInfo: [NSLocalizedDescriptionKey: String(describing: jsonErr)])
            }
            let typedCall: TypedToolCall
            if dynamic || invalid == true || errorValue != nil {
                typedCall = .dynamic(DynamicToolCall(
                    toolCallId: toolCallId,
                    toolName: toolName,
                    input: input,
                    providerExecuted: providerExecuted,
                    providerMetadata: providerMetadata,
                    invalid: invalid ?? (errorValue != nil),
                    error: errorValue
                ))
            } else {
                typedCall = .static(StaticToolCall(
                    toolCallId: toolCallId,
                    toolName: toolName,
                    input: input,
                    providerExecuted: providerExecuted,
                    providerMetadata: providerMetadata
                ))
            }
            self = .toolApprovalRequest(ToolApprovalRequestOutput(approvalId: approvalId, toolCall: typedCall))

        // Step events
        case "start-step":
            let request = try container.decode(LanguageModelRequestMetadata.self, forKey: .request)
            let warnings = try container.decode([CallWarning].self, forKey: .warnings)
            self = .startStep(request: request, warnings: warnings)

        case "finish-step":
            let response = try container.decode(LanguageModelResponseMetadata.self, forKey: .response)
            let usage = try container.decode(LanguageModelUsage.self, forKey: .usage)
            let finishReason = try container.decode(FinishReason.self, forKey: .finishReason)
            let metadata = try container.decodeIfPresent(ProviderMetadata.self, forKey: .providerMetadata)
            self = .finishStep(
                response: response,
                usage: usage,
                finishReason: finishReason,
                providerMetadata: metadata
            )

        // Stream control events
        case "start":
            self = .start

        case "finish":
            let finishReason = try container.decode(FinishReason.self, forKey: .finishReason)
            let totalUsage = try container.decode(LanguageModelUsage.self, forKey: .totalUsage)
            self = .finish(finishReason: finishReason, totalUsage: totalUsage)

        case "abort":
            self = .abort

        case "error":
            // Error is `unknown` in TypeScript, decode as JSONValue for flexibility
            if let errorValue = try? container.decode(JSONValue.self, forKey: .error) {
                // Convert JSONValue to Error
                let errorMessage = String(describing: errorValue)
                let error = NSError(
                    domain: "TextStreamPart",
                    code: -1,
                    userInfo: [NSLocalizedDescriptionKey: errorMessage]
                )
                self = .error(error)
            } else {
                let error = NSError(
                    domain: "TextStreamPart",
                    code: -1,
                    userInfo: [NSLocalizedDescriptionKey: "Unknown error"]
                )
                self = .error(error)
            }

        case "raw":
            // rawValue is `unknown` in TypeScript, decode as JSONValue
            if let rawValue = try? container.decode(JSONValue.self, forKey: .rawValue) {
                self = .raw(rawValue: rawValue)
            } else {
                self = .raw(rawValue: .null)
            }

        default:
            throw DecodingError.dataCorruptedError(
                forKey: .type,
                in: container,
                debugDescription: "Unknown TextStreamPart type: \(type)"
            )
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        // Text events
        case .textStart(let id, let metadata):
            try container.encode("text-start", forKey: .type)
            try container.encode(id, forKey: .id)
            try container.encodeIfPresent(metadata, forKey: .providerMetadata)

        case .textEnd(let id, let metadata):
            try container.encode("text-end", forKey: .type)
            try container.encode(id, forKey: .id)
            try container.encodeIfPresent(metadata, forKey: .providerMetadata)

        case .textDelta(let id, let text, let metadata):
            try container.encode("text-delta", forKey: .type)
            try container.encode(id, forKey: .id)
            try container.encode(text, forKey: .text)
            try container.encodeIfPresent(metadata, forKey: .providerMetadata)

        // Reasoning events
        case .reasoningStart(let id, let metadata):
            try container.encode("reasoning-start", forKey: .type)
            try container.encode(id, forKey: .id)
            try container.encodeIfPresent(metadata, forKey: .providerMetadata)

        case .reasoningEnd(let id, let metadata):
            try container.encode("reasoning-end", forKey: .type)
            try container.encode(id, forKey: .id)
            try container.encodeIfPresent(metadata, forKey: .providerMetadata)

        case .reasoningDelta(let id, let text, let metadata):
            try container.encode("reasoning-delta", forKey: .type)
            try container.encode(id, forKey: .id)
            try container.encode(text, forKey: .text)
            try container.encodeIfPresent(metadata, forKey: .providerMetadata)

        // Tool input events
        case .toolInputStart(let id, let toolName, let metadata, let providerExecuted, let dynamic):
            try container.encode("tool-input-start", forKey: .type)
            try container.encode(id, forKey: .id)
            try container.encode(toolName, forKey: .toolName)
            try container.encodeIfPresent(metadata, forKey: .providerMetadata)
            try container.encodeIfPresent(providerExecuted, forKey: .providerExecuted)
            try container.encodeIfPresent(dynamic, forKey: .dynamic)

        case .toolInputEnd(let id, let metadata):
            try container.encode("tool-input-end", forKey: .type)
            try container.encode(id, forKey: .id)
            try container.encodeIfPresent(metadata, forKey: .providerMetadata)

        case .toolInputDelta(let id, let delta, let metadata):
            try container.encode("tool-input-delta", forKey: .type)
            try container.encode(id, forKey: .id)
            try container.encode(delta, forKey: .delta)
            try container.encodeIfPresent(metadata, forKey: .providerMetadata)

        // Content events
        case .source(let source):
            try container.encode("source", forKey: .type)
            try source.encode(to: encoder)

        case .file(let file):
            try container.encode("file", forKey: .type)
            // Encode GeneratedFile manually
            var fileContainer = encoder.container(keyedBy: FileCodingKeys.self)
            try fileContainer.encode(file.base64, forKey: .base64)
            try fileContainer.encode(file.mediaType, forKey: .mediaType)

        // Tool execution events
        case .toolCall(let call):
            try container.encode("tool-call", forKey: .type)
            switch call {
            case .static(let v):
                try container.encode(v.toolCallId, forKey: .toolCallId)
                try container.encode(v.toolName, forKey: .toolName)
                try container.encode(v.input, forKey: .input)
                try container.encodeIfPresent(v.providerExecuted, forKey: .providerExecuted)
                try container.encodeIfPresent(v.providerMetadata, forKey: .providerMetadata)
                try container.encodeIfPresent(v.invalid, forKey: .invalid)
            case .dynamic(let v):
                try container.encode(v.toolCallId, forKey: .toolCallId)
                try container.encode(v.toolName, forKey: .toolName)
                try container.encode(v.input, forKey: .input)
                try container.encode(true, forKey: .dynamic)
                try container.encodeIfPresent(v.providerExecuted, forKey: .providerExecuted)
                try container.encodeIfPresent(v.providerMetadata, forKey: .providerMetadata)
                try container.encodeIfPresent(v.invalid, forKey: .invalid)
                if let err = v.error {
                    try container.encode(String(describing: err), forKey: .error)
                }
            }

        case .toolResult(let result):
            try container.encode("tool-result", forKey: .type)
            switch result {
            case .static(let v):
                try container.encode(v.toolCallId, forKey: .toolCallId)
                try container.encode(v.toolName, forKey: .toolName)
                try container.encode(v.output, forKey: .result)
                try container.encode(v.input, forKey: .input)
                try container.encodeIfPresent(v.providerExecuted, forKey: .providerExecuted)
                try container.encodeIfPresent(v.preliminary, forKey: .preliminary)
                try container.encodeIfPresent(v.providerMetadata, forKey: .providerMetadata)
            case .dynamic(let v):
                try container.encode(v.toolCallId, forKey: .toolCallId)
                try container.encode(v.toolName, forKey: .toolName)
                try container.encode(v.output, forKey: .result)
                try container.encode(v.input, forKey: .input)
                try container.encode(true, forKey: .dynamic)
                try container.encodeIfPresent(v.providerExecuted, forKey: .providerExecuted)
                try container.encodeIfPresent(v.preliminary, forKey: .preliminary)
                try container.encodeIfPresent(v.providerMetadata, forKey: .providerMetadata)
            }

        case .toolError(let error):
            try container.encode("tool-error", forKey: .type)
            switch error {
            case .static(let v):
                try container.encode(v.toolCallId, forKey: .toolCallId)
                try container.encode(v.toolName, forKey: .toolName)
                try container.encode(String(describing: v.error), forKey: .error)
                try container.encode(v.input, forKey: .input)
                try container.encodeIfPresent(v.providerExecuted, forKey: .providerExecuted)
            case .dynamic(let v):
                try container.encode(v.toolCallId, forKey: .toolCallId)
                try container.encode(v.toolName, forKey: .toolName)
                try container.encode(String(describing: v.error), forKey: .error)
                try container.encode(v.input, forKey: .input)
                try container.encode(true, forKey: .dynamic)
                try container.encodeIfPresent(v.providerExecuted, forKey: .providerExecuted)
            }

        case .toolOutputDenied(let denied):
            try container.encode("tool-output-denied", forKey: .type)
            // Encode ToolOutputDenied manually
            try container.encode(denied.toolCallId, forKey: .id)
            try container.encode(denied.toolName, forKey: .toolName)
            try container.encodeIfPresent(denied.providerExecuted, forKey: .providerExecuted)
            try container.encodeIfPresent(denied.dynamic, forKey: .dynamic)

        case .toolApprovalRequest(let request):
            try container.encode("tool-approval-request", forKey: .type)
            try container.encode(request.approvalId, forKey: .approvalId)
            // Flatten tool call fields for parity with other encoders
            switch request.toolCall {
            case .static(let v):
                try container.encode(v.toolCallId, forKey: .toolCallId)
                try container.encode(v.toolName, forKey: .toolName)
                try container.encode(v.input, forKey: .input)
                try container.encodeIfPresent(v.providerExecuted, forKey: .providerExecuted)
                try container.encodeIfPresent(v.providerMetadata, forKey: .providerMetadata)
                try container.encodeIfPresent(v.invalid, forKey: .invalid)
            case .dynamic(let v):
                try container.encode(v.toolCallId, forKey: .toolCallId)
                try container.encode(v.toolName, forKey: .toolName)
                try container.encode(v.input, forKey: .input)
                try container.encode(true, forKey: .dynamic)
                try container.encodeIfPresent(v.providerExecuted, forKey: .providerExecuted)
                try container.encodeIfPresent(v.providerMetadata, forKey: .providerMetadata)
                try container.encodeIfPresent(v.invalid, forKey: .invalid)
                if let err = v.error { try container.encode(String(describing: err), forKey: .error) }
            }

        // Step events
        case .startStep(let request, let warnings):
            try container.encode("start-step", forKey: .type)
            try container.encode(request, forKey: .request)
            try container.encode(warnings, forKey: .warnings)

        case .finishStep(let response, let usage, let finishReason, let metadata):
            try container.encode("finish-step", forKey: .type)
            try container.encode(response, forKey: .response)
            try container.encode(usage, forKey: .usage)
            try container.encode(finishReason, forKey: .finishReason)
            try container.encodeIfPresent(metadata, forKey: .providerMetadata)

        // Stream control events
        case .start:
            try container.encode("start", forKey: .type)

        case .finish(let finishReason, let totalUsage):
            try container.encode("finish", forKey: .type)
            try container.encode(finishReason, forKey: .finishReason)
            try container.encode(totalUsage, forKey: .totalUsage)

        case .abort:
            try container.encode("abort", forKey: .type)

        case .error(let error):
            try container.encode("error", forKey: .type)
            // Encode error as JSONValue string
            let errorValue = JSONValue.string(error.localizedDescription)
            try container.encode(errorValue, forKey: .error)

        case .raw(let rawValue):
            try container.encode("raw", forKey: .type)
            // rawValue is already JSONValue
            try container.encode(rawValue, forKey: .rawValue)
        }
    }
}

// MARK: - CustomStringConvertible

extension TextStreamPart: CustomStringConvertible {
    public var description: String {
        switch self {
        case .textStart(let id, _):
            return "textStart(id: \(id))"
        case .textEnd(let id, _):
            return "textEnd(id: \(id))"
        case .textDelta(let id, let text, _):
            return "textDelta(id: \(id), text: \(text.prefix(20))...)"
        case .reasoningStart(let id, _):
            return "reasoningStart(id: \(id))"
        case .reasoningEnd(let id, _):
            return "reasoningEnd(id: \(id))"
        case .reasoningDelta(let id, let text, _):
            return "reasoningDelta(id: \(id), text: \(text.prefix(20))...)"
        case .toolInputStart(let id, let name, _, _, _):
            return "toolInputStart(id: \(id), toolName: \(name))"
        case .toolInputEnd(let id, _):
            return "toolInputEnd(id: \(id))"
        case .toolInputDelta(let id, let delta, _):
            return "toolInputDelta(id: \(id), delta: \(delta.prefix(20))...)"
        case .source:
            return "source(...)"
        case .file(let file):
            return "file(mediaType: \(file.mediaType))"
        case .toolCall:
            return "toolCall(...)"
        case .toolResult:
            return "toolResult(...)"
        case .toolError:
            return "toolError(...)"
        case .toolOutputDenied:
            return "toolOutputDenied(...)"
        case .toolApprovalRequest:
            return "toolApprovalRequest(...)"
        case .startStep:
            return "startStep(...)"
        case .finishStep(_, _, let reason, _):
            return "finishStep(finishReason: \(reason))"
        case .start:
            return "start"
        case .finish(let reason, _):
            return "finish(finishReason: \(reason))"
        case .abort:
            return "abort"
        case .error:
            return "error(...)"
        case .raw:
            return "raw(...)"
        }
    }
}
