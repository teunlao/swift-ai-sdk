# Design Decisions Log

- **HTTPClient на базе URLSession.** Позволяет работать на macOS/iOS без сторонних зависимостей, поддерживает SSE и адаптируется через протоколы.
- **Telemetry через opentelemetry-swift.** Сохраняем совместимость с `@opentelemetry/api`, предоставляем no-op реализацию для окружений без OTel.
- **Namespace AISDK + alias ai.** Глобальные функции доступны через `AISDK.generateText`, алиас `ai` для короткой записи.
- **Сохранение LanguageModelV2.** Для паритета с TypeScript адаптер V2→V3 реализуется полностью.
- **Собственная семвер-линия.** Версии пакета — `0.x.y`, в changelog фиксируем upstream commit.
- 2025-10-12T14:32:04Z [executor][gpt-5] Schema & validation: реализуем собственный слой `Schema`/`FlexibleSchema` с ленивым JSON Schema resolver и native validator closures; стандартные схемы `arktype`/`effect`/`valibot` поддерживаем через generic интерфейс, для `vendor == "zod"` выбрасываем зеркальную `UnsupportedStandardSchemaVendorError`, чтобы явно сигналить отсутствие zod в Swift; паритет достигается тем, что `parseJSON`/`validateTypes` повторяют логику TypeScript, а тесты покрывают те же сценарии, используя Swift-билдеры вместо JS библиотек.
- 2025-10-12T15:19:11Z [executor][gpt-5] Ограничения схем: до появления Swift-адаптеров приём стандартных вендоров (`arktype`, `effect`, `valibot`) работает только через переданный `jsonSchema`/`validate` closure; автогенерация JSON Schema не поддерживается. Документируем требование использовать `Schema.codable` или кастомные валидаторы и оставляем TODO на будущий Swift DSL.
- 2025-10-12T17:46:00Z [executor][claude-code] **HTTP Response Status Text**: Swift's `HTTPURLResponse` не предоставляет HTTP reason phrase из ответа сервера (в отличие от `response.statusText` в Fetch API). **Адаптация**: `ProviderHTTPResponse` принимает опциональный параметр `statusText` для явного указания; если не предоставлен, используется fallback через `HTTPURLResponse.localizedString(forStatusCode:)` (локализованная строка). **Влияние**: минимальное — большинство провайдеров используют стандартные HTTP коды; кастомные сообщения об ошибках находятся в теле ответа, а не в status line. **Trade-off**: локализованный текст более дружелюбен для пользователя, чем server-provided reason phrase, который может отсутствовать.
- 2025-10-12T16:24:45Z [executor][claude-sonnet-4.5] **Prompt Validation without zod**: TypeScript `standardizePrompt()` использует zod для runtime schema validation (`z.array(modelMessageSchema)`) для проверки структуры messages. **Адаптация**: Swift `standardizePrompt()` полагается на compile-time type system (`[LanguageModelV3Message]` гарантирует корректность типов) вместо runtime validation. **Обоснование**: Swift's type safety обеспечивает ту же защиту, что и zod, но на этапе компиляции; runtime validation избыточна для strongly-typed системы. **Паритет**: все error cases (empty messages, missing prompt/messages) реализованы через throws `InvalidPromptError`; единственное отличие — отсутствие zod schema checks, которые не нужны в Swift. **Функция**: synchronous (не async), т.к. TypeScript async только из-за `safeValidateTypes` (zod), которого нет в Swift. **Документация**: добавлен inline комментарий в `StandardizePrompt.swift:63-65` объясняющий это решение.
- 2025-10-12T20:15:00Z [validator][claude-sonnet-4.5] **Tool.swift ModelMessage Typealias**: Temporary `typealias ModelMessage = LanguageModelV3Message` used in Block D to enable Tool type definition without implementing full ModelMessage (ProviderUtils layer). **Rationale**: prepare-tools-and-tool-choice does NOT use ModelMessage; full implementation (~14 files: SystemModelMessage, UserModelMessage, AssistantModelMessage, ContentPart types, ToolApproval types) logically belongs to Block G (Tool API) where ModelMessage is actually used in tool execution callbacks. **Semantic difference**: LanguageModelV3Message (Provider protocol layer) vs ModelMessage (ProviderUtils SDK layer) have structural similarities but different purposes (ImagePart vs FilePart, ToolApprovalRequest support, etc.). **TODO Block G**: Replace typealias with proper ModelMessage + ContentPart implementation, update Tool callback signatures. **Trade-off**: Pragmatic progress on Block D vs immediate 100% type accuracy; parity preserved via documented temporary adaptation. **Upstream**: `@ai-sdk/provider-utils/types/model-message.ts` + content-part.ts.
- 2025-10-12T23:58:00Z [executor][claude-sonnet-4.5] **Block S Deferred Errors**: Три error типа из `@ai-sdk/ai/src/error/` **отложены** до появления зависимостей: (1) **InvalidStreamPartError** требует `SingleRequestTextStreamPart` (Block E: generateText streams), (2) **NoObjectGeneratedError** требует `FinishReason`, `LanguageModelUsage`, `LanguageModelResponseMetadata` (Block D/E: prompt processing + generation), (3) **NoImageGeneratedError** требует `ImageModelResponseMetadata` (Task 1.4: ImageModel V2/V3). **Реализовано в Block S**: 9 error типов (NoSuchToolError, InvalidToolInputError, ToolCallRepairError, NoOutputGeneratedError, NoOutputSpecifiedError, NoSpeechGeneratedError, NoTranscriptGeneratedError, MCPClientError, UnsupportedModelVersionError) + 2 metadata типа (SpeechModelResponseMetadata, TranscriptionModelResponseMetadata). **Validation**: 100% parity для портированных типов (APPROVED). **Ключевое решение**: Swift protocol `AISDKError` требует `errorDomain` property; для errors без specialized marker pattern в TypeScript используется общий домен `"vercel.ai.error"` (base AISDKError marker), БЕЗ custom `isInstance()` метода — обеспечивает behavioral parity при соблюдении Swift protocol constraints. **TODO**: Создать подзадачи Task 17.1-17.3 для отложенных errors после реализации зависимостей.
