# Design Decisions Log

- **HTTPClient на базе URLSession.** Позволяет работать на macOS/iOS без сторонних зависимостей, поддерживает SSE и адаптируется через протоколы.
- **Telemetry через opentelemetry-swift.** Сохраняем совместимость с `@opentelemetry/api`, предоставляем no-op реализацию для окружений без OTel.
- **Namespace AISDK + alias ai.** Глобальные функции доступны через `AISDK.generateText`, алиас `ai` для короткой записи.
- **Сохранение LanguageModelV2.** Для паритета с TypeScript адаптер V2→V3 реализуется полностью.
- **Собственная семвер-линия.** Версии пакета — `0.x.y`, в changelog фиксируем upstream commit.
- 2025-10-12T14:32:04Z [executor][gpt-5] Schema & validation: реализуем собственный слой `Schema`/`FlexibleSchema` с ленивым JSON Schema resolver и native validator closures; стандартные схемы `arktype`/`effect`/`valibot` поддерживаем через generic интерфейс, для `vendor == "zod"` выбрасываем зеркальную `UnsupportedStandardSchemaVendorError`, чтобы явно сигналить отсутствие zod в Swift; паритет достигается тем, что `parseJSON`/`validateTypes` повторяют логику TypeScript, а тесты покрывают те же сценарии, используя Swift-билдеры вместо JS библиотек.
- 2025-10-12T15:19:11Z [executor][gpt-5] Ограничения схем: до появления Swift-адаптеров приём стандартных вендоров (`arktype`, `effect`, `valibot`) работает только через переданный `jsonSchema`/`validate` closure; автогенерация JSON Schema не поддерживается. Документируем требование использовать `Schema.codable` или кастомные валидаторы и оставляем TODO на будущий Swift DSL.
- 2025-10-12T17:46:00Z [executor][claude-code] **HTTP Response Status Text**: Swift's `HTTPURLResponse` не предоставляет HTTP reason phrase из ответа сервера (в отличие от `response.statusText` в Fetch API). **Адаптация**: `ProviderHTTPResponse` принимает опциональный параметр `statusText` для явного указания; если не предоставлен, используется fallback через `HTTPURLResponse.localizedString(forStatusCode:)` (локализованная строка). **Влияние**: минимальное — большинство провайдеров используют стандартные HTTP коды; кастомные сообщения об ошибках находятся в теле ответа, а не в status line. **Trade-off**: локализованный текст более дружелюбен для пользователя, чем server-provided reason phrase, который может отсутствовать.
- 2025-10-12T16:24:45Z [executor][claude-sonnet-4.5] **Prompt Validation without zod**: TypeScript `standardizePrompt()` использует zod для runtime schema validation (`z.array(modelMessageSchema)`) для проверки структуры messages. **Адаптация**: Swift `standardizePrompt()` полагается на compile-time type system (`[LanguageModelV3Message]` гарантирует корректность типов) вместо runtime validation. **Обоснование**: Swift's type safety обеспечивает ту же защиту, что и zod, но на этапе компиляции; runtime validation избыточна для strongly-typed системы. **Паритет**: все error cases (empty messages, missing prompt/messages) реализованы через throws `InvalidPromptError`; единственное отличие — отсутствие zod schema checks, которые не нужны в Swift. **Функция**: synchronous (не async), т.к. TypeScript async только из-за `safeValidateTypes` (zod), которого нет в Swift. **Документация**: добавлен inline комментарий в `StandardizePrompt.swift:63-65` объясняющий это решение.
- 2025-10-12T20:15:00Z [validator][claude-sonnet-4.5] **Tool.swift ModelMessage Typealias**: Temporary `typealias ModelMessage = LanguageModelV3Message` used in Block D to enable Tool type definition without implementing full ModelMessage (ProviderUtils layer). **Rationale**: prepare-tools-and-tool-choice does NOT use ModelMessage; full implementation (~14 files: SystemModelMessage, UserModelMessage, AssistantModelMessage, ContentPart types, ToolApproval types) logically belongs to Block G (Tool API) where ModelMessage is actually used in tool execution callbacks. **Semantic difference**: LanguageModelV3Message (Provider protocol layer) vs ModelMessage (ProviderUtils SDK layer) have structural similarities but different purposes (ImagePart vs FilePart, ToolApprovalRequest support, etc.). **TODO Block G**: Replace typealias with proper ModelMessage + ContentPart implementation, update Tool callback signatures. **Trade-off**: Pragmatic progress on Block D vs immediate 100% type accuracy; parity preserved via documented temporary adaptation. **Upstream**: `@ai-sdk/provider-utils/types/model-message.ts` + content-part.ts.
- 2025-10-12T23:58:00Z [executor][claude-sonnet-4.5] **Block S Deferred Errors**: Три error типа из `@ai-sdk/ai/src/error/` **отложены** до появления зависимостей: (1) **InvalidStreamPartError** требует `SingleRequestTextStreamPart` (Block E: generateText streams), (2) **NoObjectGeneratedError** требует `FinishReason`, `LanguageModelUsage`, `LanguageModelResponseMetadata` (Block D/E: prompt processing + generation), (3) **NoImageGeneratedError** требует `ImageModelResponseMetadata` (Task 1.4: ImageModel V2/V3). **Реализовано в Block S**: 9 error типов (NoSuchToolError, InvalidToolInputError, ToolCallRepairError, NoOutputGeneratedError, NoOutputSpecifiedError, NoSpeechGeneratedError, NoTranscriptGeneratedError, MCPClientError, UnsupportedModelVersionError) + 2 metadata типа (SpeechModelResponseMetadata, TranscriptionModelResponseMetadata). **Validation**: 100% parity для портированных типов (APPROVED). **Ключевое решение**: Swift protocol `AISDKError` требует `errorDomain` property; для errors без specialized marker pattern в TypeScript используется общий домен `"vercel.ai.error"` (base AISDKError marker), БЕЗ custom `isInstance()` метода — обеспечивает behavioral parity при соблюдении Swift protocol constraints. **TODO**: Создать подзадачи Task 17.1-17.3 для отложенных errors после реализации зависимостей.
- 2025-10-13T01:15:00Z [executor][claude-sonnet-4.5] **Block 21 Mock Models Array Indexing Bug Fix**: TypeScript upstream (`mock-language-model-v2.ts` и `mock-language-model-v3.ts`) содержит off-by-one bug в array mode: использует `doGenerateCalls.length` ПОСЛЕ `push()`, что дает индексы 1, 2, 3... вместо 0, 1, 2... **Последствия**: первый элемент массива никогда не используется, последний вызов возвращает `undefined`. **Баг присутствует с марта 2024**, не обнаружен т.к. (1) mock utilities не имеют тестов в upstream, (2) array mode редко используется, (3) JavaScript возвращает `undefined` без crash. **Решение Swift**: используем правильную индексацию `doGenerateCalls.count - 1`, что дает корректные индексы 0, 1, 2... **Обоснование**: (1) mock models это тестовая инфраструктура, не public API — низкий риск отклонения, (2) perpetuating бага в новой кодовой базе контрпродуктивно, (3) Swift должен быть reference implementation с правильным поведением, (4) если upstream исправит баг, наш код уже правильный (future-proof). **Документация**: полный анализ бага в `insights/upstream-bug-mock-array-indexing.md` (10,000 слов на русском). **Parity trade-off**: жертвуем bug-for-bug compatibility ради корректности; приоритет на правильную тестовую инфраструктуру. **Upstream recommendation**: создать issue в vercel/ai с описанием бага и предложением исправления.
- 2025-10-13T03:45:00Z [executor][claude-sonnet-4.5] **Task 23: SwiftPM Package Restructuring**: Реструктуризация монолитного `SwiftAISDK` в 3 отдельных SwiftPM пакета, полностью повторяющих upstream архитектуру `@ai-sdk`. **Структура**: (1) **AISDKProvider** (78 files, no deps) - foundation types (LanguageModel V2/V3, errors, JSONValue, middleware protocols) from `@ai-sdk/provider`, (2) **AISDKProviderUtils** (35 files, depends on Provider) - utilities (HTTP, JSON, schema, tools) from `@ai-sdk/provider-utils`, (3) **SwiftAISDK** (105 files, depends on both + EventSourceParser) - main SDK (generateText, prompts, registry, telemetry, middleware) from `@ai-sdk/ai`. **Dependency graph**: AISDKProvider → AISDKProviderUtils → SwiftAISDK (matches upstream package.json). **Moves**: `Provider/*` → `AISDKProvider/`, `ProviderUtils/*` → `AISDKProviderUtils/`, `Core/*` → `SwiftAISDK/` (flattened); исправлены locations: `DataContent.swift`, `SplitDataUrl.swift` перемещены в AISDKProviderUtils (matches upstream `@ai-sdk/provider-utils`). **Imports**: AISDKProvider (no imports), AISDKProviderUtils (`import AISDKProvider`), SwiftAISDK (`import AISDKProvider` + `import AISDKProviderUtils`); обработана ambiguity `getErrorMessage()` через qualified calls `AISDKProvider.getErrorMessage()` (matches upstream imports). **Tests**: созданы 3 test targets (AISDKProviderTests, AISDKProviderUtilsTests, SwiftAISDKTests); все 763 теста пройдены. **Result**: ✅ Build успешен (2.33s), ✅ 763/763 tests passed, ✅ no circular dependencies, ✅ git history preserved (`git mv`), ✅ 100% upstream parity. **Rationale**: разделение на пакеты улучшает modularity, снижает compile-time dependencies, позволяет использовать только Provider types без main SDK, облегчает тестирование и соответствует upstream architecture. **Breaking change**: import statements обновлены для 3-package structure; consumers должны явно импортировать нужные пакеты. **Documentation**: обновлены README.md (package structure), CLAUDE.md (paths), plan/principles.md (architecture), plan/executor-guide.md (code placement rules).

- 2025-10-13T15:55:32Z [executor][gpt-5] **JSON Schema для инструментов (блок 5.4)**: добавлен лёгкий валидатор `JSONSchemaValidator` и специализированная перегрузка `jsonSchema(_:) -> Schema<JSONValue>`, чтобы повторить поведение Zod (конверсия необработанных `[String: Any]` в `JSONValue`, проверка `required` и `additionalProperties`). Метод `jsonValue(from:)` сделан публичным, а `SchemaValidationResult.passthrough` научен транслировать `JSONValue` без отдельного валидатора. Это устранило `SchemaTypeMismatchError` в `parseToolCall`, `InvalidToolInputError` формируется с теми же сообщениями, что в TypeScript, и тесты (`ParseToolCallTests`, `ExecuteToolTests`, `ToResponseMessagesTests`, `SchemaTests`) покрывают все сценарии upstream. Дополнительно `executeToolCall` и `toResponseMessages` используют преобразование `jsonValueToAny` + `getErrorMessage` для идентичной сериализации результатов и ошибок.

- 2025-10-13T16:21:30Z [executor][gpt-5] **ExecuteTool: финальное событие при пустом стриме**: Swift-реализация теперь всегда эмитирует `.final(Output?)`, даже если AsyncThrowingStream не выдал значений (паритет с TypeScript, где final output может быть `undefined`). Для non-stream cases итоговое значение остаётся обязательным, для стримов финальное событие содержит `nil`, и `executeToolCall` конвертирует его в `JSONValue.null`. Тест `ExecuteToolTests.emptyStreamYieldsFinal` обновлён: ожидается ровно одно финальное событие с `output == nil`, что подтверждает соответствие upstream и исправляет замечание валидации.