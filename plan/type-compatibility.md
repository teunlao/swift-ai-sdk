# Совместимость контрактов Language Model

## Контекст
- В Vercel AI SDK (коммит 77db222e…) одновременно существуют `LanguageModelV2` и `LanguageModelV3`.
- В2 предоставляет старый контракт провайдера, V3 — обновлённый (AI SDK 5.0).
- Функция `resolveLanguageModel` в TypeScript оборачивает V2 в прокси, подменяя `specificationVersion` на `v3` и проксируя остальные свойства.

## Решение для Swift порта
1. Описать тип `LanguageModelV2` (структура/протокол) идентично TypeScript.
2. Описать тип `LanguageModelV3` как основную внутреннюю модель.
3. Реализовать адаптер `LanguageModelAdapter.transformToV3(_:)`, который:
   - Проверяет `specificationVersion`.
   - Для `v2` создаёт прокси-обёртку (либо struct, либо класс с делегированием) и возвращает `LanguageModelV3`.
   - Для `v3` возвращает модель как есть.
4. Вся внутренняя логика генерации/стриминга работает с V3, чтобы избежать дублирования кода.
5. Публичные API принимают `LanguageModel` (аналоги TypeScript union), что позволяет пользователю передавать как строковый ID (`provider:model`), так и явно созданный объект V2/V3.

## Причины
- Сохранение полного паритета с TypeScript-кодом.
- Совместимость с существующими кастомными провайдерами, написанными на V2.
- Упрощение миграции, когда Vercel полностью перейдёт на V3: нам просто нужно будет повторить их шаги.

## TODO
- После реализации адаптера дополнить документ ссылками на конкретные Swift-файлы.
