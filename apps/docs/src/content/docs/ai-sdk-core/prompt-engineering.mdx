---
title: Prompt Engineering
description: Learn how to develop prompts with AI SDK Core.
---

_This page adapts the original AI SDK documentation: [Prompt Engineering](https://ai-sdk.dev/docs/ai-sdk-core/prompt-engineering)._ 

# Prompt Engineering

## Tips

### Prompts for Tools

When you create prompts that include tools, getting good results can be tricky as the number and complexity of your tools increases.

Here are a few tips to help you get the best results:

1. Use a model that is strong at tool calling, such as `gpt-4` or `gpt-4.1`. Weaker models will often struggle to call tools effectively and flawlessly.
1. Keep the number of tools low, e.g. to 5 or less.
1. Keep the complexity of the tool parameters low. Complex JSON schemas with many nested and optional elements, unions, etc. can be challenging for the model to work with.
1. Use semantically meaningful names for your tools, parameters, parameter properties, etc. The more information you pass to the model, the better it can understand what you want.
1. Add descriptive metadata to your JSON schema properties (for example a `"description"` field) to give the model hints about what each property is for.
1. When the output of a tool might be unclear to the model and there are dependencies between tools, use the `description` field of a tool to provide information about the output of the tool execution.
1. You can include example input/outputs of tool calls in your prompt to help the model understand how to use the tools. Keep in mind that the tools work with JSON objects, so the examples should use JSON.

In general, the goal should be to give the model all information it needs in a clear way.

### Tool & Structured Data Schemas

The mapping from Swift schemas (for example `FlexibleSchema(jsonSchema(...))` or `Schema.codable(...)`) to the JSON that an LLM consumes is not always straightforward, since the mapping is not one-to-one.

#### Date Handling

Models return dates as strings. Specify the format in the schema and convert the string to a `Date` after generation (or configure a decoder when using `Schema.codable`).

```swift highlight="8-18,26"
import SwiftAISDK
import OpenAIProvider
import AISDKProviderUtils

struct Event: Decodable {
  let event: String
  let date: Date
}

struct EventsResponse: Decodable {
  let events: [Event]
}

let eventsSchema = FlexibleSchema(
  Schema.codable(
    EventsResponse.self,
    jsonSchema: .object([
      "type": .string("object"),
      "properties": .object([
        "events": .object([
          "type": .string("array"),
          "items": .object([
            "type": .string("object"),
            "properties": .object([
              "event": .object([
                "type": .string("string")
              ]),
              "date": .object([
                "type": .string("string"),
                "format": .string("date-time"),
                "description": .string("ISO 8601 date string")
              ])
            ]),
            "required": .array([.string("event"), .string("date")])
          ])
        ])
      ]),
      "required": .array([.string("events")]),
      "additionalProperties": .bool(false)
    ]),
    configureDecoder: { decoder in
      decoder.dateDecodingStrategy = .iso8601
      return decoder
    }
  )
)

let result = try await generateObject(
  model: openai("gpt-4.1"),
  output: .object(schema: eventsSchema, schemaName: "Events"),
  prompt: "List 5 important events from the year 2000."
)

let events = result.object.events
```

#### Optional Parameters

When working with tools that have optional parameters, you may encounter compatibility issues with certain providers that use strict schema validation.

> Note
> This is particularly relevant for OpenAI models with structured outputs (strict mode).

For maximum compatibility, optional parameters should be marked as `nullable` instead of omitting them entirely. The schema should list the required fields explicitly and allow nullable values for optional ones:

```swift highlight="11-18,29-36"
import SwiftAISDK
import AISDKProviderUtils

let failingTool = tool(
  description: "Execute a command",
  inputSchema: FlexibleSchema(jsonSchema(.object([
    "type": .string("object"),
    "properties": .object([
      "command": .object(["type": .string("string")]),
      "workdir": .object(["type": .string("string")]),
      "timeout": .object(["type": .string("string")])
    ]),
    "required": .array([.string("command")])
  ]))),
  execute: { _, _ in .value(.object([:])) }
)

let workingTool = tool(
  description: "Execute a command",
  inputSchema: FlexibleSchema(jsonSchema(.object([
    "type": .string("object"),
    "properties": .object([
      "command": .object(["type": .string("string")]),
      "workdir": .object([
        "type": .string("string"),
        "nullable": .bool(true)
      ]),
      "timeout": .object([
        "type": .string("string"),
        "nullable": .bool(true)
      ])
    ]),
    "required": .array([.string("command")])
  ]))),
  execute: { _, _ in .value(.object([:])) }
)
```

#### Temperature Settings

For tool calls and object generation, it's recommended to use `temperature: 0` to ensure deterministic and consistent results:

```swift highlight="3"
import SwiftAISDK
import OpenAIProvider
import AISDKProviderUtils

let result = try await generateText(
  model: openai("gpt-4o"),
  temperature: 0, // Recommended for tool calls
  tools: [
    "myTool": tool(
      description: "Execute a command",
      inputSchema: FlexibleSchema(jsonSchema(.object([
        "type": .string("object"),
        "properties": .object([
          "command": .object(["type": .string("string")])
        ]),
        "required": .array([.string("command")])
      ]))),
      execute: { _, _ in .value(.object([:])) }
    )
  ],
  prompt: "Execute the ls command"
)
```

Lower temperature values reduce randomness in model outputs, which is particularly important when the model needs to:

- Generate structured data with specific formats
- Make precise tool calls with correct parameters
- Follow strict schemas consistently

## Debugging

### Inspecting Warnings

Not all providers support all AI SDK features. Providers either throw exceptions or return warnings when they do not support a feature. To check if your prompt, tools, and settings are handled correctly by the provider, inspect the call warnings:

```swift
import SwiftAISDK
import OpenAIProvider

let result = try await generateText(
  model: openai("gpt-4o"),
  prompt: "Hello, world!"
)

print(result.warnings ?? [])
```

### HTTP Request Bodies

You can inspect the raw HTTP request bodies for models that expose them, e.g. [OpenAI](/providers/ai-sdk-providers/openai). This allows you to inspect the exact payload that is sent to the model provider in the provider-specific way.

Request bodies are available via the `request.body` property of the response:

```swift highlight="6"
import SwiftAISDK
import OpenAIProvider

let result = try await generateText(
  model: openai("gpt-4o"),
  prompt: "Hello, world!"
)

print(String(describing: result.request.body))
```
