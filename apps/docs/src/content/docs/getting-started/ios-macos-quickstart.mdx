---
title: iOS & macOS Quickstart
description: Build a SwiftUI app that uses the Swift AI SDK for text generation and streaming.
---

This guide shows how to add the Swift AI SDK to an iOS or macOS app, call models, and stream results into your UI.

## 1) Install via Swift Package Manager

In Xcode: File → Add Package Dependencies…

- Package URL: https://github.com/teunlao/swift-ai-sdk
- Add products: `SwiftAISDK`, `OpenAIProvider` (and other providers as needed)

## 2) Configure API Keys

Set environment variables in your scheme or via a secure configuration:

```text
OPENAI_API_KEY=sk-...
```

The default provider shortcuts (e.g., `openai`) read standard env vars automatically.

## 3) Minimal call (blocking)

```swift
import SwiftAISDK
import OpenAIProvider

let result = try await generateText(
  model: openai("gpt-4o"),
  prompt: "Hello from Swift!"
)
print(result.text)
```

## 4) Streaming in SwiftUI

```swift
import SwiftUI
import SwiftAISDK
import OpenAIProvider

@MainActor
final class ChatViewModel: ObservableObject {
  @Published var output: String = ""
  @Published var isLoading = false

  func send(_ prompt: String) {
    isLoading = true
    output = ""
    Task {
      do {
        let stream = try streamText(
          model: openai("gpt-5"),
          prompt: prompt
        )
        for try await delta in stream.textStream {
          output += delta
        }
      } catch {
        output = "Error: \(error)"
      }
      isLoading = false
    }
  }
}

struct ChatView: View {
  @StateObject var vm = ChatViewModel()
  @State var input = "Write a haiku about vectors"

  var body: some View {
    VStack(alignment: .leading) {
      TextEditor(text: $input).frame(height: 120)
      Button(vm.isLoading ? "Streaming…" : "Send") { vm.send(input) }
      ScrollView { Text(vm.output).monospaced() }
    }
    .padding()
  }
}
```

## 5) Tools (optional)

### Manual JSON Schema

```swift
import AISDKProviderUtils

let echo = tool(
  description: "Echo back the input data",
  inputSchema: FlexibleSchema(jsonSchema(
    .object([
      "type": .string("object"),
      "properties": .object([
        "message": .object([
          "type": .string("string"),
          "description": .string("The message to echo")
        ])
      ]),
      "required": .array([.string("message")]),
      "additionalProperties": .bool(false)
    ])
  )),
  execute: { input, _ in .value(input) }
)

let result = try await generateText(
  model: openai("gpt-5"),
  tools: ["echo": echo],
  prompt: "Call echo with {\"message\":\"Hello!\"}"
)
```

### Zod-like Schema (cleaner!)

```swift
import AISDKProviderUtils
import AISDKZodAdapter

let calculator = tool(
  description: "Perform arithmetic operations",
  inputSchema: flexibleSchemaFromZod3(z.object([
    "operation": z.string(),
    "a": z.number(),
    "b": z.number()
  ])),
  execute: { input, _ in
    guard case .object(let obj) = input,
          case .string(let op) = obj["operation"] ?? .null,
          case .number(let a) = obj["a"] ?? .null,
          case .number(let b) = obj["b"] ?? .null else {
      return .value(.string("Invalid input"))
    }

    let result: Double
    switch op {
    case "add": result = a + b
    case "multiply": result = a * b
    default: result = 0
    }

    return .value(.number(result))
  }
)

let result = try await generateText(
  model: openai("gpt-5"),
  tools: ["calculator": calculator],
  prompt: "What is 234 multiplied by 89?"
)
```

> **Note:** The Zod-like DSL (`z.object()`, `z.string()`, etc.) provides a cleaner way to define schemas. Use `flexibleSchemaFromZod3()` to convert ZodSchema to FlexibleSchema.

> Keep long‑running work off the main actor; UI updates should be marshalled on the main thread.

