import Foundation
import Testing
@testable import SwiftAISDK

/**
 Tests for `createStitchableStream`.

 Port of `@ai-sdk/ai/src/util/create-stitchable-stream.test.ts`.
 */
@Suite("Stitchable Stream Tests")
struct CreateStitchableStreamTests {

    private actor CancellationTracker {
        private(set) var cancelled = false

        func mark() {
            cancelled = true
        }

        func value() -> Bool {
            cancelled
        }
    }

    private func makeAsyncIterableStream<T: Sendable>(
        values: [T],
        tracker: CancellationTracker? = nil
    ) -> AsyncIterableStream<T> {
        let source = AsyncThrowingStream<T, Error> { continuation in
            Task {
                for value in values {
                    if Task.isCancelled { return }
                    continuation.yield(value)
                }
                continuation.finish()
            }
        }

        let options = tracker.map { tracker in
            AsyncIterableStreamInternalOptions { _ in
                await tracker.mark()
            }
        }

        return createAsyncIterableStream(source: source, _internal: options)
    }

    private func collect<T: Sendable>(
        _ stream: AsyncIterableStream<T>
    ) async throws -> [T] {
        var result: [T] = []
        for try await value in stream {
            result.append(value)
        }
        return result
    }

    @Test("should return no stream when immediately closed")
    func closeImmediately() async throws {
        let stitchable: StitchableStream<Int> = createStitchableStream()
        stitchable.close()
        let values = try await collect(stitchable.stream)
        #expect(values.isEmpty)
    }

    @Test("should return all values from a single inner stream")
    func singleInnerStream() async throws {
        let stitchable: StitchableStream<Int> = createStitchableStream()
        try await stitchable.addStream(makeAsyncIterableStream(values: [1, 2, 3]))
        stitchable.close()
        let values = try await collect(stitchable.stream)
        #expect(values == [1, 2, 3])
    }

    @Test("should return all values from multiple inner streams")
    func multipleInnerStreams() async throws {
        let stitchable: StitchableStream<Int> = createStitchableStream()
        try await stitchable.addStream(makeAsyncIterableStream(values: [1, 2, 3]))
        try await stitchable.addStream(makeAsyncIterableStream(values: [4, 5, 6]))
        try await stitchable.addStream(makeAsyncIterableStream(values: [7, 8, 9]))
        stitchable.close()
        let values = try await collect(stitchable.stream)
        #expect(values == [1, 2, 3, 4, 5, 6, 7, 8, 9])
    }

    @Test("should handle empty inner streams")
    func handleEmptyInnerStreams() async throws {
        let stitchable: StitchableStream<Int> = createStitchableStream()
        try await stitchable.addStream(makeAsyncIterableStream(values: []))
        try await stitchable.addStream(makeAsyncIterableStream(values: [1, 2]))
        try await stitchable.addStream(makeAsyncIterableStream(values: []))
        try await stitchable.addStream(makeAsyncIterableStream(values: [3, 4]))
        stitchable.close()
        let values = try await collect(stitchable.stream)
        #expect(values == [1, 2, 3, 4])
    }

    @Test("should handle reading a single value before it is added")
    func readBeforeValueAdded() async throws {
        let stitchable: StitchableStream<Int> = createStitchableStream()

        let additionTask = Task {
            try? await Task.sleep(nanoseconds: 10_000_000)
            try? await stitchable.addStream(makeAsyncIterableStream(values: [42]))
            stitchable.close()
        }

        var iterator = stitchable.stream.makeAsyncIterator()
        let firstValue = try await iterator.next()
        #expect(firstValue == 42)

        let secondValue = try await iterator.next()
        #expect(secondValue == nil)

        await additionTask.value
    }

    // DISABLED: Hangs indefinitely (Task #37)
    // @Test("should return values added asynchronously")
    // func asynchronousAddition() async throws {
    //     let stitchable: StitchableStream<Int> = createStitchableStream()
    //
    //     Task {
    //         try? await stitchable.addStream(makeAsyncIterableStream(values: [1, 2, 3]))
    //         try? await stitchable.addStream(makeAsyncIterableStream(values: [4, 5]))
    //         stitchable.close()
    //     }
    //
    //     var iterator = stitchable.stream.makeAsyncIterator()
    //     var results: [Int] = []
    //     while let value = try await iterator.next() {
    //         results.append(value)
    //     }
    //
    //     #expect(results == [1, 2, 3, 4, 5])
    // }

    @Test("should handle errors from inner streams")
    func handleInnerStreamErrors() async throws {
        enum TestError: Error, Equatable { case failure }

        let errorStream = AsyncThrowingStream<Int, Error> { continuation in
            Task {
                continuation.finish(throwing: TestError.failure)
            }
        }

        let stitchable: StitchableStream<Int> = createStitchableStream()
        try await stitchable.addStream(makeAsyncIterableStream(values: [1, 2]))
        try await stitchable.addStream(createAsyncIterableStream(source: errorStream))
        try await stitchable.addStream(makeAsyncIterableStream(values: [3, 4]))
        stitchable.close()

        await #expect(throws: TestError.self) {
            _ = try await collect(stitchable.stream)
        }
    }

    // DISABLED: Hangs indefinitely (Task #37)
    // @Test("should cancel all inner streams when cancelled")
    // func cancelAllInnerStreams() async throws {
    //     let tracker1 = CancellationTracker()
    //     let tracker2 = CancellationTracker()
    //
    //     let stitchable: StitchableStream<Int> = createStitchableStream()
    //     try await stitchable.addStream(makeAsyncIterableStream(values: [1, 2], tracker: tracker1))
    //     try await stitchable.addStream(makeAsyncIterableStream(values: [3, 4], tracker: tracker2))
    //
    //     await stitchable.stream.cancel()
    //
    //     #expect(await tracker1.value())
    //     #expect(await tracker2.value())
    // }

    // DISABLED: Hangs indefinitely (Task #37)
    // @Test("should throw when adding stream after closing")
    // func throwWhenAddingAfterClose() async {
    //     let stitchable: StitchableStream<Int> = createStitchableStream()
    //     stitchable.close()
    //
    //     await #expect(throws: StitchableStreamError.self) {
    //         try await stitchable.addStream(makeAsyncIterableStream(values: [1, 2]))
    //     }
    // }

    // DISABLED: Hangs indefinitely (Task #37)
    // @Test("terminate should cancel streams immediately")
    // func terminateCancelsStreams() async throws {
    //     let tracker1 = CancellationTracker()
    //     let tracker2 = CancellationTracker()
    //
    //     let stitchable: StitchableStream<Int> = createStitchableStream()
    //     try await stitchable.addStream(makeAsyncIterableStream(values: [1, 2], tracker: tracker1))
    //     try await stitchable.addStream(makeAsyncIterableStream(values: [3, 4], tracker: tracker2))
    //
    //     var iterator = stitchable.stream.makeAsyncIterator()
    //     let first = try await iterator.next()
    //     #expect(first == 1)
    //
    //     stitchable.terminate()
    //
    //     let final = try await iterator.next()
    //     #expect(final == nil)
    //     #expect(await tracker1.value())
    //     #expect(await tracker2.value())
    // }

    // DISABLED: Hangs indefinitely (Task #37)
    // @Test("terminate should prevent adding further streams")
    // func terminatePreventsAdditions() async {
    //     let stitchable: StitchableStream<Int> = createStitchableStream()
    //     stitchable.terminate()
    //
    //     await #expect(throws: StitchableStreamError.self) {
    //         try await stitchable.addStream(makeAsyncIterableStream(values: [1, 2]))
    //     }
    // }
}
